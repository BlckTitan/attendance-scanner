 const selectedSeats = () =>{
        return seat.filter((_, index) => index % 2 === 0); 
    }
    const getSeatOptions = () =>{
        
        return seat.filter(s => s.startsWith('t') || s.startsWith('H'))
    }
    // function to handle user seat selection
    const handleSeatSelection = () =>{
        //if the user clicks a button, then let them choose from the list of seats regardless of the table
        const selectedSeatOptions =  selectedSeats()// seatOptions only
        
        const isAlreadySelected = seat.includes(seatId.seatOption);
        
        if (isAlreadySelected) {
            // Remove both seatOption and name
            seatId.setSeat(seat.filter((s) => s !== seatId.seatOption && s !== seatId.name));
            //trigger table deselection on click
        } else {
            selectedSeats()
            // Only add if selection limit not exceeded
            if (selectedSeatOptions.length < numberOfSeats) {
                seatId.setSeat([...seat, seatId.seatOption, seatId.name]);
                setName(seatId.name)
                setSeatOption(seatId.seatOption)
                // No need to call deriveTables here, handled in useEffect
            } else {
                Toast({ type: 'warning', message: 'Maximum seat selection reached.' })
            }
        }
    }
    
    // function to handle table selection when user picks a seat
    const handleTableSelection = (
        seatOptions: string[]
    ): string[] => {
        //1.Find every table whose seat list intersects the incoming seatOptions
        const matchingTableIds = tableSeatOptions
            .filter(({ options }) =>
                options.some(opt => seatOptions.includes(opt))
            )
            .map(({ id }) => id);

        // Remove duplicates by using a Set
        const merged = new Set([...table, ...matchingTableIds]);

        let newTableData: array[] = [];
        
        for (let i = 0; i < matchingTableIds.length; i++) {
            newTableData.push({
                table: matchingTableIds[i],
                name: name[i],
                option: setSeatOption[i]
            });

        }
        
        setCurrentTable([...currentTable, ...newTableData]);

        return Array.from(merged);
    }

    const handleTableDeselect = (selectedSeatOptions: string[]) =>{

        //if the user clicks a button, then let them choose from the list of seats regardless of the table
        
        // Keep every table that still owns ≥1 selected seat
        const matchingTableIds = tableSeatOptions
            .filter(({ options }) =>
                options.some(opt => selectedSeatOptions.includes(opt))
            )
            .map(({ id }) => id);
        setTable(matchingTableIds); // no accidental nesting
    }

    useEffect(() => {
        // table selection trigger

        // get the options for every seat
        const selectedSeatOptions = getSeatOptions()

        setTable(handleTableSelection(selectedSeatOptions));

        handleTableDeselect(selectedSeatOptions)
        
    }, [seat, setTable]);
    
    currentTable.map((item) => {
        console.log(item)
    }, [currentTable])


    // c. Build new rows for currentTable
            const newTableData = seat
            .filter((s) => seatOptions.includes(s.option)).map((s) => {
            //     // find the table that owns this seat option
            //     const tableId =
            //         tableSeatOptions.find((ts) => ts.options.includes(s.option))?.id ?? "";
            //     return { table: tableId, name: s.name, option: s.option };
            });
            // d. Append (immutably) to currentTable
            // setCurrentTable((prev) => [...prev, ...newTableData]);
    
            const result = table
            .map(tableItem => {
                const match = seat.find(seatItem => seatItem.option.toLowerCase().startsWith(tableItem.toLowerCase()));
                return match
                ? { table: tableItem, name: match.name, option: match.option }
                : null;
            })
            .filter((item): item is { table: string; name: string; option: string } => item !== null); // type guard
    
            setCurrentTable(result)






            07/01/25

            const selectedSeats = () =>{
        return seat.filter((_, index) => index % 2 === 0); 
    }

    const getSeatOptions = () =>{
        
        return seat.filter(s => s.option.startsWith('t') || s.option.startsWith('H')).map((s) => s.option);
        
    }

    // function to handle user seat selection
    const handleSeatSelection = () =>{
        //if the user clicks a button, then let them choose from the list of seats regardless of the table
        const selectedSeatOptions =  selectedSeats()// seatOptions only
        
        const isAlreadySelected = seat.some(
            (s) => s.option === seatId.seatOption && s.name === seatId.name
        );

        if (isAlreadySelected) {
            // Remove the seat by both option and name
            const updatedSeats = seat.filter(
                (s) => s.option !== seatId.seatOption && s.name !== seatId.name
            );
            seatId.setSeat(updatedSeats);
        } else {
            selectedSeats()
            // Only add if selection limit not exceeded
            if (selectedSeatOptions.length < numberOfSeats) {
                seatId.setSeat([...seat,{option: seatId.seatOption, name: seatId.name}]);
                // No need to call deriveTables here, handled in useEffect
            } else {
                Toast({ type: 'warning', message: 'Maximum seat selection reached.' })
            }
        }
    }
    
    // function to handle table selection when user picks a seat
    const handleTableSelection = (
        seatOptions: string[]
    ): string[] => {
        //1.Find every table whose seat list intersects the incoming seatOptions
        const matchingTableIds = tableSeatOptions
            .filter(({ options }) =>
                options.some(opt => seatOptions.includes(opt))
            )
            .map(({ id }) => id);

        // b. Merge with tables already selected, dedup with a Set
        const mergedTableIds = Array.from(new Set([...table, ...matchingTableIds]));


        return mergedTableIds; // return updated list so caller can setTable
    }

    const handleTableDeselect = (seatOptions: string[]) =>{

        //if the user clicks a button, then let them choose from the list of seats regardless of the table
        
        // Keep every table that still owns ≥1 selected seat
        const stillSelectedIds  = tableSeatOptions
            .filter(({ options }) =>
                options.some(opt => seatOptions.includes(opt))
            )
            .map(({ id }) => id);
        setTable(stillSelectedIds ); // no accidental nesting
    }

    useEffect(() => {
        // table selection trigger

        // get the options for every seat
        const seatOptions = getSeatOptions()

        setTable(handleTableSelection(seatOptions));

        handleTableDeselect(seatOptions)
        
    }, [seat, setTable]);

    console.log(seat, table)